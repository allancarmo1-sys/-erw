local Debris = game:GetService("Debris")
local CollectionService = game:GetService("CollectionService")

local RS = game:GetService("ReplicatedStorage")
local Services = RS:WaitForChild("MyServices"):WaitForChild("Services")
local CharacterStats = require(Services:WaitForChild("CharacterStats"))

local CombatUtils = {}

function CombatUtils:GetAllEnemies()
	local enemies = CollectionService:GetTagged("ZombieEntity")
	print("GetAllEnemies:" .. #enemies, enemies)
	return enemies
end

function CombatUtils:GetNearestEnemy(character, range)
	if not character then return nil end
	local myRoot = character:FindFirstChild("HumanoidRootPart")
	if not myRoot then return nil end

	local nearest = nil
	local minDst = range * CharacterStats:GetStat(game.Players:GetPlayerFromCharacter(character), "Range")

	local rayParams = RaycastParams.new()
	rayParams.FilterType = Enum.RaycastFilterType.Exclude
	rayParams.FilterDescendantsInstances = {character}

	for _, enemy in ipairs(CollectionService:GetTagged("ZombieEntity")) do
		local enemyHum = enemy:FindFirstChild("Humanoid")
		local enemyRoot = enemy:FindFirstChild("HumanoidRootPart")

		if enemyHum and enemyHum.Health > 0 and enemyRoot then
			local dist = (enemyRoot.Position - myRoot.Position).Magnitude

			if dist < minDst then

				local direction = (enemyRoot.Position - myRoot.Position)
				local result = workspace:Raycast(myRoot.Position, direction, rayParams)

				local isVisible = false

				if result then
					if result.Instance:IsDescendantOf(enemy) then
						isVisible = true
					else
						isVisible = false
					end
				else
					isVisible = true
				end

				if isVisible then
					minDst = dist
					nearest = enemyHum
				end
			end
		end
	end

	return nearest
end

function CombatUtils.TagHumanoid(enemyHumanoid, player)
	if not enemyHumanoid or not player then return end

	local existingTag = enemyHumanoid:FindFirstChild("creator")
	if existingTag then
		existingTag:Destroy()
	end

	local tag = Instance.new("ObjectValue")
	tag.Name = "creator" 
	tag.Value = player   
	tag.Parent = enemyHumanoid

	Debris:AddItem(tag, 2) 
end

function CombatUtils.ApplyKnockback(enemyRoot, direction, force)
	if not enemyRoot or force <= 0 then return end

	local att = Instance.new("Attachment")
	att.Parent = enemyRoot

	local kb = Instance.new("LinearVelocity")
	kb.Name = "KnockbackForce"
	kb.Attachment0 = att
	kb.MaxForce = math.huge 
	kb.VectorVelocity = direction * force 
	kb.RelativeTo = Enum.ActuatorRelativeTo.World
	kb.Parent = enemyRoot

	-- 0.15s is a good impact feel
	Debris:AddItem(kb, 0.15) 
	Debris:AddItem(att, 0.15)
end

function CombatUtils.DealDamage(player, enemyHumanoid, weaponStats)
	local baseDamage = weaponStats.Damage
	local knockback = (weaponStats.Knockback + CharacterStats:GetStat(player, "Knockback"))
	local isElite = enemyHumanoid.Parent:GetAttribute("Elite")

	if not player or not enemyHumanoid or enemyHumanoid.Health <= 0 then return end

	local dmgMult = CharacterStats:GetStat(player, "Damage")
	local finalDamage = math.floor(baseDamage * dmgMult)
	
	if isElite then
		finalDamage *= CharacterStats:GetStat(player, "DamageToElites")
	end
	
	CombatUtils.TagHumanoid(enemyHumanoid, player)
	enemyHumanoid:TakeDamage(finalDamage)

	if knockback > 0 and enemyHumanoid.Parent then
		
		if isElite then
			return finalDamage
		end
		
		local root = enemyHumanoid.Parent:FindFirstChild("HumanoidRootPart")
		if root then
			local char = player.Character
			if char and char.PrimaryPart then
				local pushDir = (root.Position - char.PrimaryPart.Position).Unit

				local isFlying = root:FindFirstChildOfClass("BodyPosition") 
					or root:FindFirstChildOfClass("AlignPosition")
					or root:FindFirstChildOfClass("LinearVelocity")

				if not isFlying then
					pushDir = Vector3.new(pushDir.X, 0, pushDir.Z).Unit 
				else
					pushDir = Vector3.new(pushDir.X, 0.2, pushDir.Z).Unit 
				end

				CombatUtils.ApplyKnockback(root, pushDir, knockback)
			end
		end
	end

	return finalDamage
end

return CombatUtils
