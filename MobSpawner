local ServerStorage = game:GetService("ServerStorage")
local Players = game:GetService("Players")
local CollectionService = game:GetService("CollectionService")
local MobRegistry = require(game.ServerScriptService.MobRegistry)

local Spawner = {}
Spawner.__index = Spawner

local MobsFolder = ServerStorage:WaitForChild("Mobs")

function Spawner.new()
	return setmetatable({}, Spawner)
end

function Spawner:CalculateStats(baseStats, difficultyMulti, playerCount)
	local playerFactor = 1 + ((playerCount - 1) * 0.25)
	local calculatedEXP = math.floor((baseStats.BaseEXP or 10) * difficultyMulti)

	return {
		ModelName = baseStats.ModelName or "Creep",
		MaxHealth = math.floor(baseStats.Health * difficultyMulti * playerFactor),
		Damage = math.floor(baseStats.Damage * difficultyMulti),
		Speed = baseStats.Speed * (1 + (difficultyMulti - 1) * 0.1),
		EXP = calculatedEXP,
		Lifetime = baseStats.Lifetime,
		Elite = baseStats.Elite 
	}
end

function Spawner:SpawnZombie(stats, position)
	local sourceModel = MobsFolder:FindFirstChild(stats.ModelName)
	if not sourceModel then warn("Model not found:", stats.ModelName) return end

	local clone = sourceModel:Clone()

	local hum = clone:FindFirstChild("Humanoid")
	if hum then
		hum.MaxHealth = stats.MaxHealth
		hum.Health = stats.MaxHealth
		hum.WalkSpeed = stats.Speed
	end
	
	MobRegistry.SetData(clone, stats)

	clone:PivotTo(CFrame.new(position))
	clone.Parent = workspace
	CollectionService:AddTag(clone, "ZombieEntity")
	clone:SetAttribute("Elite", stats.Elite)
	
	return clone
end

function Spawner:ChooseZombieType(tableData)
	local total = 0
	for _, d in pairs(tableData) do total = total + d.Weight end
	local r = math.random() * total
	local c = 0
	for _, d in pairs(tableData) do
		c = c + d.Weight
		if r <= c then return d end
	end
	return tableData[1]
end

local function GetValidSpawnPoint(center, minD, maxD)
	for i = 1, 10 do
		local angle = math.rad(math.random(0, 360))
		local dist = math.random(minD, maxD)
		local spawnPos = center + Vector3.new(math.cos(angle)*dist, 50, math.sin(angle)*dist)

		local rayParams = RaycastParams.new()
		rayParams.FilterType = Enum.RaycastFilterType.Exclude
		rayParams.FilterDescendantsInstances = {workspace:FindFirstChild("Zombies")}

		local result = workspace:Raycast(spawnPos, Vector3.new(0, -100, 0), rayParams)
		if result then return result.Position + Vector3.new(0, 3, 0) end
	end
	return nil
end

function Spawner:StartWave(mapData, difficultyRating, playerCount, waveConfig)

	return task.spawn(function()
		local waveDuration = waveConfig.Duration or 60
		local waveEndTime = tick() + waveDuration

		-- Calculate Spawn Speed
		local baseFreq = waveConfig.BaseFrequency or 2.0
		local spawnDelay = baseFreq / (difficultyRating * math.sqrt(playerCount))
		spawnDelay = math.clamp(spawnDelay, 0.1, 5.0)

		print(string.format("Starting: [%s] | Delay: %.2fs", waveConfig.Name, spawnDelay))

		while tick() < waveEndTime do
			local allPlayers = Players:GetPlayers()

			if #allPlayers > 0 then
				local target = allPlayers[math.random(1, #allPlayers)]

				if target and target.Character and target.Character.PrimaryPart then
					local center = target.Character.PrimaryPart.Position

					if waveConfig.Pattern == "Circle" then
						local count = 8
						local angleStep = 360 / count

						for i = 1, count do
							local chosenType = self:ChooseZombieType(waveConfig.Mobs)
							local finalStats = self:CalculateStats(chosenType, difficultyRating, playerCount)

							local r = math.rad(i * angleStep)
							local offset = Vector3.new(math.cos(r) * waveConfig.MinDist, 50, math.sin(r) * waveConfig.MinDist)

							local rayParams = RaycastParams.new()
							rayParams.FilterType = Enum.RaycastFilterType.Exclude
							rayParams.FilterDescendantsInstances = {workspace:FindFirstChild("Zombies"), workspace:FindFirstChild("Drops")}

							local res = workspace:Raycast(center + offset, Vector3.new(0, -100, 0), rayParams)

							if res then 
								self:SpawnZombie(finalStats, res.Position + Vector3.new(0, 3, 0)) 
							end

							if i % 4 == 0 then task.wait() end
						end
						task.wait(spawnDelay * 4) 

					else
						local pos = GetValidSpawnPoint(center, waveConfig.MinDist, waveConfig.MaxDist)

						if pos then
							local chosenType = self:ChooseZombieType(waveConfig.Mobs)
							local finalStats = self:CalculateStats(chosenType, difficultyRating, playerCount)

							self:SpawnZombie(finalStats, pos)
						end

						task.wait(spawnDelay)
					end
				else
					task.wait(1)
				end
			else
				task.wait(1)
			end
		end
		print("Wave Duration Ended.")
	end)
end

function Spawner:SpawnBoss(bossData, difficultyRating, playerCount)
	print("Spawner: Attempting to spawn Boss...")

	local allPlayers = game:GetService("Players"):GetPlayers()
	if #allPlayers == 0 then return nil end

	local target = allPlayers[math.random(1, #allPlayers)]
	if not target.Character then return nil end

	local center = target.Character.PrimaryPart.Position

	local spawnPos = GetValidSpawnPoint(center, 60, 100)

	if not spawnPos then
		warn("Spawner: Could not find valid ground for Boss!")
		return nil
	end

	local finalStats = self:CalculateStats(bossData, difficultyRating, playerCount)

	local bossModel = self:SpawnZombie(finalStats, spawnPos)

	if bossModel then
		print("Spawner: Boss Spawned successfully at", spawnPos)

		-- Optional: Add a special "Boss" tag for UI bars
		game:GetService("CollectionService"):AddTag(bossModel, "Boss")

		return bossModel
	end

	return nil
end

return Spawner
