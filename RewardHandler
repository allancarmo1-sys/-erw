local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Services = ReplicatedStorage:WaitForChild("MyServices"):WaitForChild("Services")
local CharacterStats = require(Services:WaitForChild("CharacterStats"))

local RewardHandler = {}

local RARITY_DATA = {
	{ Name = "Common",    Weight = 70,  Mult = 1.0, Color = Color3.fromRGB(200, 200, 200) },
	{ Name = "Uncommon",  Weight = 25,  Mult = 1.5, Color = Color3.fromRGB(50, 200, 50)   },
	{ Name = "Rare",      Weight = 10,  Mult = 2.0, Color = Color3.fromRGB(50, 50, 255)   },
	{ Name = "Epic",      Weight = 4,   Mult = 2.5, Color = Color3.fromRGB(200, 50, 200)  },
	{ Name = "Legendary", Weight = 1,   Mult = 3.0, Color = Color3.fromRGB(255, 150, 0)   }
}

local WEAPON_CONFIG = {
	["Sniper"] = { 
		Type = "Weapon",
		Stats = { "Damage", "Cooldown", "ProjectileSpeed" }, 
		BaseIncrements = { Damage = 2, Cooldown = 2, ProjectileSpeed = 2 } 
	},
	["Boomerang"] = { 
		Type = "Weapon",
		Stats = { "Damage", "Range" },
		BaseIncrements = { Damage = 2, Range = 2 } 
	},
	["Bouncy"] = { 
		Type = "Weapon",
		Stats = { "Damage", "PierceCount" },
		BaseIncrements = { Damage = 2, PierceCount = 1 } 
	}
}

local CHARM_CONFIG = {
	["Spinach"] = { Type = "Charm", Stat = "Damage", BaseIncrement = { Damage = 1 }, Desc = "Damage" },
	["Clover"]  = { Type = "Charm", Stat = "Luck",   BaseIncrement = { Luck = 10 },   Desc = "Luck" },
	["Feather"]  = { Type = "Charm", Stat = "Jump",   BaseIncrement = { JumpPower = 1 },   Desc = "Jump" },
}

local function GetPlayerInventory(player)
	local stats = CharacterStats.GetStats(player)
	local ownedWeapons = {}
	local ownedCharms = {}
	local wCount, cCount = 0, 0

	if stats and stats.Inventory then
		for id, _ in pairs(stats.Inventory.Weapons) do
			ownedWeapons[id] = true
			wCount = wCount + 1
		end
		for id, _ in pairs(stats.Inventory.Charms) do
			ownedCharms[id] = true
			cCount = cCount + 1
		end
	end
	return ownedWeapons, ownedCharms, wCount, cCount
end

local function RollRarity(playerLuck)
	local totalWeight = 0
	local pool = {}
	local luckFactor = math.max(0, playerLuck) / 50 

	for _, rarity in ipairs(RARITY_DATA) do
		local weight = rarity.Weight
		if rarity.Name == "Common" then
			weight = math.max(1, weight - (luckFactor * 10))
		else
			weight = weight + (weight * luckFactor)
		end
		table.insert(pool, { Data = rarity, Weight = weight })
		totalWeight += weight
	end

	local r = math.random() * totalWeight
	local c = 0
	for _, entry in ipairs(pool) do
		c += entry.Weight
		if r <= c then return entry.Data end
	end
	return RARITY_DATA[1]
end

function RewardHandler.RollOptions(player, optionCount)
	optionCount = optionCount or 3
	local ownedWep, ownedCharm, wCount, cCount = GetPlayerInventory(player)
	local playerLuck = CharacterStats:GetStat(player, "Luck")
	local maxWep = CharacterStats:GetStat(player, "MaxWeapons")
	local maxCharm = CharacterStats:GetStat(player, "MaxCharms")

	local possiblePool = {}

	for id, data in pairs(WEAPON_CONFIG) do
		if ownedWep[id] then
			table.insert(possiblePool, { Id = id, Type = "Weapon", IsNew = false, Config = data })
		elseif wCount < maxWep then
			table.insert(possiblePool, { Id = id, Type = "Weapon", IsNew = true, Config = data })
		end
	end
	for id, data in pairs(CHARM_CONFIG) do
		if ownedCharm[id] then 
			table.insert(possiblePool, { Id = id, Type = "Charm", IsNew = false, Config = data })
		elseif cCount < maxCharm then
			table.insert(possiblePool, { Id = id, Type = "Charm", IsNew = true, Config = data })
		end
	end

	local options = {}

	for i = 1, optionCount do
		if #possiblePool == 0 then break end
		local idx = math.random(1, #possiblePool)
		local choice = possiblePool[idx]
		table.remove(possiblePool, idx)

		local rarity = RollRarity(playerLuck)
		local optionData = {
			Id = choice.Id,
			Name = choice.Id,
			Type = choice.Type,
			IsNew = choice.IsNew,
			Rarity = rarity.Name,
			RarityColor = rarity.Color,
			Description = "",
			Payload = {}
		}

		if choice.Type == "Weapon" then
			if choice.IsNew then
				optionData.Description = "New Weapon! Base Stats."
				optionData.Payload = { Damage = 1, Cooldown = 1, Range = 1, ProjectileSpeed = 1 } 
			else
				local statsList = choice.Config.Stats
				local numUpgrades = math.random(1, 2)
				local descParts = {}
				local shuffled = {unpack(statsList)}
				for k = #shuffled, 2, -1 do 
					local j = math.random(k)
					shuffled[k], shuffled[j] = shuffled[j], shuffled[k]
				end

				for s = 1, math.min(numUpgrades, #shuffled) do
					local statName = shuffled[s]
					local baseInc = choice.Config.BaseIncrements[statName] or 0
					local finalInc = baseInc * rarity.Mult

					if math.abs(finalInc) < 1 then finalInc = math.floor(finalInc * 100) / 100
					else finalInc = math.floor(finalInc) end

					optionData.Payload[statName] = finalInc
					local sign = (finalInc > 0) and "+" or ""
					table.insert(descParts, string.format("%s%s %s", sign, finalInc, statName))
				end
				optionData.Description = table.concat(descParts, ", ")
			end

		elseif choice.Type == "Charm" then
			if choice.IsNew then
				-- FIX: Pass the actual stats table, not the name string
				optionData.Description = "New Charm! Increases " .. choice.Config.Desc
				optionData.Payload = choice.Config.BaseIncrement 
			else
				-- FIX: Handle table math correctly
				local baseTable = choice.Config.BaseIncrement
				local payload = {}
				local descParts = {}

				for stat, baseVal in pairs(baseTable) do
					local finalInc = baseVal * rarity.Mult

					if math.abs(finalInc) < 1 then finalInc = math.floor(finalInc * 100) / 100
					else finalInc = math.floor(finalInc) end

					payload[stat] = finalInc

					local sign = (finalInc > 0) and "+" or ""
					table.insert(descParts, string.format("%s%s %s", sign, finalInc, stat))
				end

				optionData.Payload = payload
				optionData.Description = table.concat(descParts, ", ")
			end
		end
		
		if choice.IsNew then
			optionData.RarityColor = Color3.fromRGB(255, 255, 255)
		end

		table.insert(options, optionData)
	end

	return options
end

return RewardHandler
