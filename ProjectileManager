local RunService = game:GetService("RunService")
local CollectionService = game:GetService("CollectionService")

local RS = game:GetService("ReplicatedStorage")
local Services = RS:WaitForChild("MyServices"):WaitForChild("Services")
local CharacterStats = require(Services:WaitForChild("CharacterStats"))

local CombatUtils = require(Services:WaitForChild("CombatUtils"))
local VisualEvent = RS:WaitForChild("VisualProjectileEvent")

local ProjectileManager = {}
local activeProjectiles = {}

local HITBOX_SIZE = 4 

local function GetZombieFromPart(part)
	if not part then return nil end

	--if CollectionService:HasTag(part, "ZombieEntity") then return part end

	local current = part
	while current and current ~= workspace do
		if CollectionService:HasTag(current, "ZombieEntity") then
			return current
		end
		current = current.Parent
	end
	return nil

	--local model = part:FindFirstAncestorOfClass("Model")
	--if model and CollectionService:HasTag(model, "ZombieEntity") then return model end

	--return nil
end

local function FindBounceTarget(currentPos, range, ignoreList)
	local bestTarget = nil
	local minDist = range
	for _, enemy in ipairs(CollectionService:GetTagged("ZombieEntity")) do
		if not ignoreList[enemy] then 
			local root = enemy:FindFirstChild("HumanoidRootPart")
			local hum = enemy:FindFirstChild("Humanoid")
			if root and hum and hum.Health > 0 then
				local dist = (root.Position - currentPos).Magnitude
				if dist < minDist then
					minDist = dist
					bestTarget = enemy
				end
			end
		end
	end
	return bestTarget
end

function ProjectileManager.Fire(ownerPlayer, startPos, targetOrDir, stats)
	local isHoming = typeof(targetOrDir) == "Instance"
	local characterStats = CharacterStats:GetStats(ownerPlayer)

	local initialDir = Vector3.new(0,0,1)
	if not isHoming then
		initialDir = targetOrDir.Unit
	elseif targetOrDir and targetOrDir.Parent and targetOrDir.Parent:FindFirstChild("HumanoidRootPart") then
		initialDir = (targetOrDir.Parent.HumanoidRootPart.Position - startPos).Unit
	end

	local maxDist = nil

	if stats.IsBoomerang then
		maxDist = (stats.Range - 60)
	elseif isHoming and targetOrDir then
		maxDist = 500 
	elseif not isHoming then
		maxDist = stats.Range 
	end

	local projectile = {
		Owner = ownerPlayer,
		Position = startPos,
		StartPos = startPos,
		Speed = stats.ProjectileSpeed,
		Color = stats.ProjectileColor,

		DamageStats = stats,
		HitsRemaining = (stats.PierceCount + characterStats.Bounces),
		IsPiercing = stats.IsPiercing,
		BounceRange = stats.BounceRange,
		
		IsSniper = stats.IsSniper,
		IsRicochet = stats.IsRicochet,
		IsBoomerang = stats.IsBoomerang,
		ProjMaxDist = (stats.Range - 60),
		IsReturning = false,

		IsHoming = isHoming,
		Target = isHoming and targetOrDir or nil,
		Direction = not isHoming and targetOrDir.Unit or nil, -- change this last

		HitHistory = {},
		Lifetime = 5,
		BirthTime = tick()
	}

	table.insert(activeProjectiles, projectile)

	VisualEvent:FireAllClients(startPos, targetOrDir, stats.ProjectileSpeed, stats.ProjectileColor, stats.IsBoomerang, stats.IsSniper, stats.ProjMaxDist)
end

RunService.Heartbeat:Connect(function(dt)
	for i = #activeProjectiles, 1, -1 do
		local proj = activeProjectiles[i]

		if tick() - proj.BirthTime > proj.Lifetime then
			table.remove(activeProjectiles, i); continue
		end

		local currentPos = proj.Position
		local nextPos
		local moveStep = proj.Speed * dt

		if proj.IsHoming then
			local validTarget = false

			if proj.IsReturning and proj.Target:IsA("Player") and proj.Target.Character then
				local root = proj.Target.Character:FindFirstChild("HumanoidRootPart")
				if root then
					local dir = (root.Position - currentPos).Unit
					nextPos = currentPos + (dir * moveStep)
					proj.Direction = dir
					validTarget = true
					if (root.Position - currentPos).Magnitude < 3 then
						table.remove(activeProjectiles, i); continue
					end
				end

			elseif proj.Target and proj.Target.Parent then
				local root = proj.Target.Parent:FindFirstChild("HumanoidRootPart")
				if root then
					local dir = (root.Position - currentPos).Unit
					nextPos = currentPos + (dir * moveStep)
					proj.Direction = dir
					validTarget = true
				end
			end

			if not validTarget then
				proj.IsHoming = false
				nextPos = currentPos + (proj.Direction * moveStep)
			end
		else
			nextPos = currentPos + (proj.Direction * moveStep)
		end

		if proj.IsBoomerang and not proj.IsReturning then
			if (currentPos - proj.StartPos).Magnitude >= proj.ProjMaxDist then
				
				proj.IsReturning = true
				proj.IsHoming = true
				proj.Target = proj.Owner
				proj.HitHistory = {} 

				VisualEvent:FireAllClients(currentPos, proj.Owner.Character.HumanoidRootPart, proj.Speed, proj.Color, proj.IsBoomerang, proj.IsSniper, proj.ProjMaxDist)
				print("returned boomerang")
			end
		end

		local dist = (nextPos - currentPos).Magnitude
		local dir = (nextPos - currentPos).Unit

		local rayParams = RaycastParams.new()
		rayParams.FilterType = Enum.RaycastFilterType.Exclude

		local ignoreList = {}
		if proj.Owner.Character then table.insert(ignoreList, proj.Owner.Character) end

		local dropsFolder = workspace:FindFirstChild("Drops")
		if dropsFolder then table.insert(ignoreList, dropsFolder) end

		local debrisFolder = workspace:FindFirstChild("Debris")
		if debrisFolder then table.insert(ignoreList, debrisFolder) end

		-- other projectiles like other physical stuff idk
		-- table.insert(ignoreList, workspace:FindFirstChild("Projectiles")) 

		rayParams.FilterDescendantsInstances = ignoreList

		local hitResult = workspace:Raycast(currentPos, dir * dist, rayParams)

		if not hitResult and proj.IsHoming and proj.Target and not proj.Target:IsA("Player") then
			local tRoot = proj.Target.Parent and proj.Target.Parent:FindFirstChild("HumanoidRootPart")
			if tRoot and (tRoot.Position - nextPos).Magnitude < HITBOX_SIZE then
				hitResult = {Instance = tRoot} 
			end
		end

		if hitResult then
			local enemyModel = GetZombieFromPart(hitResult.Instance)

			if enemyModel then
				if not proj.HitHistory[enemyModel] then
					local hum = enemyModel:FindFirstChild("Humanoid")
					if hum and hum.Health > 0 then
						proj.HitHistory[enemyModel] = true
						proj.HitsRemaining = proj.HitsRemaining - 1
						CombatUtils.DealDamage(proj.Owner, hum, proj.DamageStats) -- add damage tracker here

						if proj.HitsRemaining <= 0 then
							table.remove(activeProjectiles, i)
						else
							if proj.IsRicochet then
								local newTarget = FindBounceTarget(nextPos, proj.BounceRange, proj.HitHistory)

								if newTarget then
									local newHum = newTarget:FindFirstChild("Humanoid")
									proj.IsHoming = true
									proj.Target = newHum
									proj.Position = nextPos

									VisualEvent:FireAllClients(nextPos, newHum, proj.Speed, proj.Color)
								else
									table.remove(activeProjectiles, i)
								end
							end
							
							if proj.IsPiercing then
								proj.Position = nextPos 
							end

							if proj.IsHoming and not proj.IsReturning and not proj.IsRicochet then
								proj.IsHoming = false 
								proj.Target = nil
							end
							
						end
					end
				else
					proj.Position = nextPos
				end
			else
				if hitResult.Instance.CanCollide then
					if proj.IsBoomerang --[[and proj.IsReturning]] then
						proj.Position = nextPos 
					else
						table.remove(activeProjectiles, i)
					end
				else
					proj.Position = nextPos
				end
			end
		else
			proj.Position = nextPos
		end
	end
end)

return ProjectileManager
